"""
- CSE Graduation project

The script performs pre-converting tasks for a given VHDL file.
These tasks should prevent the vhdl2verilog common issues when converting
flopoco VHDL output cores.

The script implements three different functions
+ split_vhdl(vfile) : splits the given VHDL flopoco file <vfile> into n different
files where each file has a single entity with its architecture

+ replace_vhdl() : attempts to replace the VHDL statements that cause conversion issues
into an equivalent synthesizable VHDL statements.

+ convert() : attempts to call the vhdl2verilog executable against all the files
"""

import sys
import os
import re


def split_vhdl(vhdl_file, gen_dir):
    """
    Spilts the VHDL single file into n files each with a single
    entity

    ## Arguments
    + vhdl_file : relative path to the single vhdl file generated by flopoco
    + gen_dir : a user given string for the directory to generate the vhdl files into
    """
    hdl_file = ''.join(open(vhdl_file, 'r').readlines())

    module_names = []
    entity_tail = 0
    try:
        os.mkdir(gen_dir)
    except:
        print("Directory Already exists, attempting to OVERWRITE old modules if they exist")
    while True:
        entity_head = hdl_file.find('----')
        entity_tail = hdl_file.find('end architecture')
        if entity_tail == -1:
            break
        entity_name = hdl_file[hdl_file.index('entity ')+7:
                               hdl_file.find(' ', hdl_file.index('entity ')+7)]
        module_names.append(entity_name)
        with open(gen_dir+'/'+entity_name+'.vhdl', "w") as single_entity:
            single_entity.write(hdl_file[entity_head:entity_tail+18])
        hdl_file = hdl_file[entity_tail+18:]
    print("Found ", len(module_names), "Modules")
    [print('\t'+i) for i in module_names]
    print("Modules Separated Successfully!")
    return module_names


def replace_vhdl(vhdl_file):
    """
    Attempts to remove un-supported statements that causes problem for the converting tool.
    Currently the unsupported statements are
    + CONV_STD_LOGIC_VECTOR(num,bit_length) : should be replaced by the equivalent
    value of the binary number<num>
    with bit length of <bit_length>
    + <msb downto lsb => val> : should be replaced by replicating the value for <msb-lsb+1> times
    """

    hdl_file = open(vhdl_file, 'r').readlines()
    num_fixed = 0
    for i, line in enumerate(hdl_file):
        # change CONV_STD_LOGIC_VECTOR VHDL function
        conv_idx_head = line.find('CONV_STD_LOGIC_VECTOR')
        if conv_idx_head == -1:
            conv_idx_head = line.find('CONV_STD_LOGIC_VECTOR'.lower())
        if conv_idx_head != -1:
            conv_idx_tail = line.find(')', conv_idx_head)+1
            operands = [int(i) for i in line[conv_idx_head+22:conv_idx_tail-1].split(',')]
            replaced_vector = '"' + ("{0:0"+str(operands[1])+"b}").format(operands[0]) + '"'
            hdl_file[i] = hdl_file[i].replace(line[conv_idx_head:conv_idx_tail], replaced_vector)
            #print(line[conv_idx_head:conv_idx_tail])
            #print (hdl_file[i])
        bit_concat_list = re.findall(r'\(\d+ downto \d+ ?=> ?\'?\w+\'?\)', line)
        _complex_signal = False
        if len(bit_concat_list) == 0:
            bit_concat_list = re.findall(r'\(\d+ downto \d+ ?=> ?\w+\(\d+\)\)', line)
        if len(bit_concat_list) == 0:
            bit_concat_list = re.findall(r'\(\d+ downto \d+ ?=> ?not? \w+\(\d+\)\)', line)
            _complex_signal = True
        if len(bit_concat_list) != 0:
            for expr in bit_concat_list:
                _expr = expr
                if (expr[expr.find('=>')-1] !=' '):
                    #print(expr)
                    _expr = expr.replace('=>', ' => ')
                fo = _expr[1:-1].split()
                lhs = int(fo[0])
                rhs = int(fo[2])
                val_var = fo[-1]
                if _complex_signal:
                    val_var = fo[-2] + ' ' + fo[-1]
                replicate = lhs-rhs + 1
                replacement = ""
                num_fixed += 1
                if val_var.find("'") == -1:
                    # it is a variable
                    replacement = '(' + ((val_var + '&')*replicate)[:-1] + ')'
                else:
                    # a bit replicated
                    val_var = val_var.replace("'", "")
                    if replicate > 1:
                        replacement = '("' + ((val_var)*replicate) + '")'
                    else:
                        replacement = "('" + ((val_var)*replicate) + "')"
                hdl_file[i] = hdl_file[i].replace(expr, replacement)
                #print(_expr, replacement)
        if line.find('attribute') !=- 1:
            hdl_file[i] = line.replace('attribute', '--attribute')
    with open(vhdl_file, "w") as full_entity:
        for i in hdl_file:
            full_entity.write(i)
    print("Found ", num_fixed, " statements to be replaced")
    print("Unsupported statements Replaced Successfully!")



## Main code
VHDL_GENERATE_DIR = "converted_files"
VHDL_FILE_NAME = sys.argv[1]
VHDL_GENERATE_DIR = sys.argv[2]
replace_vhdl(VHDL_FILE_NAME)
DETECTED_MODULES = split_vhdl(VHDL_FILE_NAME, VHDL_GENERATE_DIR)
FULL_RTL = ""
for i in DETECTED_MODULES:
    print("Executing: ", "./vhd2vl " + VHDL_GENERATE_DIR + '/' + i +'.vhdl ' + i +'.v')
    os.system("./vhd2vl " + VHDL_GENERATE_DIR + '/' + i +'.vhdl ' + VHDL_GENERATE_DIR + '/' + i +'.v')
    with open(VHDL_GENERATE_DIR + '/' + i +'.v', 'r') as myrtl:
        FULL_RTL += myrtl.read()
    os.system("rm " + VHDL_GENERATE_DIR + '/' + i +'.v')

os.system("rm " + VHDL_GENERATE_DIR + '/' + '*.vhdl')
with open(VHDL_GENERATE_DIR + '/' + DETECTED_MODULES[-1] +'.v', 'w') as myrtl:
    myrtl.write(FULL_RTL)
