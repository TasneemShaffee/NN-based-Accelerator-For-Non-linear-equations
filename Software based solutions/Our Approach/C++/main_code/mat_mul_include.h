#ifndef __MAT_VECT_INCLUDE__
#define __MAT_VECT_INCLUDE__
/*
 * Testing the HLS dummy interface for generating dot-product+trainer engine
 * Current high level design parameters are
 * 	 + MAX_WEIGHT_MEM_DEPTH		: the maximum synthesized weight memory depth
 * 	 			              	  also sets the bit-width of the row memory address
 * 	 + NUM_PE					: the number of the processing elements to synthesize
 * 	 + beta1,2					: the Adam  training parameters. Fixed once synthesized
 * 	 + sub_beta1,2				: the subtraction of beta term. Fixed once synthesized
*/


const unsigned int MAX_WEIGHT_MEM_DEPTH = 15000;
const unsigned int NUM_PE = 2;

const float beta1 = 0.9;
const float beta2 = 0.999;
const float adam_eta = 0.001;
const float adam_small_step = 1e-8;
const float sub_beta1 = 1-beta1;
const float sub_beta2 = 1-beta2;
typedef unsigned char uint8;

void mat_vect(float ROW[MAX_WEIGHT_MEM_DEPTH][NUM_PE],		// Input memory
  float ROOT_MEM[MAX_WEIGHT_MEM_DEPTH],
  float BEST_W_MEM[MAX_WEIGHT_MEM_DEPTH],
  float V_MEMORY[MAX_WEIGHT_MEM_DEPTH],				        // Adam velocity memory
  float M_MEMORY[MAX_WEIGHT_MEM_DEPTH],						// Adam mass memory
  const  unsigned int max_rows[4],                                   // maximum row size
  const unsigned int  pe_ratio[4],									// matrix_col:pe ratio
  const unsigned int i_offst_vect_idx[4],							// input current layer vector read offset
  const unsigned int i_offst_w_idx[4],							// input current layer weight read offset
  const unsigned int i_offst_result_idx[4],						// input current layer result offset
  float net_memory[MAX_WEIGHT_MEM_DEPTH],                   // net value separate memory
  const  bool train_mode,                                   // current training mode 0:MANHATTAN, 1:ADAM
  const uint8 lut_idx[MAX_WEIGHT_MEM_DEPTH],         // The number of vect_in belonging to each lut
  const  uint8  current_layer,
  const float eta_val,
  const float eta_step,
  float& lastKnownError,
  bool& switchBestWeights);


void top_module(float WEIGHT_MEM[MAX_WEIGHT_MEM_DEPTH][NUM_PE],         // Coeff memory [generated by the software]
  float ROOT_MEM[MAX_WEIGHT_MEM_DEPTH],                                 // Solution memory
  float BEST_W_MEM[MAX_WEIGHT_MEM_DEPTH],
  float V_MEMORY[MAX_WEIGHT_MEM_DEPTH],				                          // Adam velocity memory
  float M_MEMORY[MAX_WEIGHT_MEM_DEPTH],						                      // Adam mass memory
  const  unsigned int max_rows[4],                                      // row size for each iteration [generated by the software]
  const unsigned int   pe_ratio[4],									                    // matrix size to num_pe ratio for each iteration [generated by the software]
  const unsigned int i_offst_vect_idx[4],						                          // input offset index [generated by the software]
  const unsigned int i_offst_w_idx[4],							                          // weight offset index [generated by the software] 
  const unsigned int i_offst_result_idx[4],						                        // intermediate results offset index [generated by the software]
  float net_memory[MAX_WEIGHT_MEM_DEPTH],
  const uint8 lut_idx[MAX_WEIGHT_MEM_DEPTH],
  const unsigned int iter_mem[3],
  const float requiredError,
  float& currentError,
  bool& rootMemIdx
);

#endif
